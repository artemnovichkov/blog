---
title: Async/await for existing iOS apps
description: Using new concurrency model with SwiftUI apps
cover: /images/swiftui-offline/cover.png
date: '2021-11-17'
author:
  - artem-novichkov
---

Previously I wrote a post about [working with web view content offline](https://www.artemnovichkov.com/blog/swiftui-offline). Since then Apple team have released Xcode 13.2 beta with Swift 5.5, I've read a book about [modern concurrency model in Swift](https://www.raywenderlich.com/books/modern-concurrency-in-swift), and I guess it's a perfect time to update my examples with async/await!

Before reading this post I highly recommend to check [Concurrency](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html) article in Swift Language Guide.

> Note: Code examples are written in Swift 5.5 and tested on iOS 15.0 with Xcode 13.2 (13C5081f).

## Preparation

Let's brush up on the implementation of `WebDataManager` that allows us to get data for web content by URL:

```swift
final class WebDataManager: NSObject {
  
    // Another properties and types
    
    private var completionHandler: ((Result<Data, Error>) -> Void)?
    
    func createData(url: URL, type: DataType, completionHandler: @escaping (Result<Data, Error>) -> Void) {
        self.type = type
        self.completionHandler = completionHandler
        webView.load(.init(url: url))
    }
}
```

Because `WKWebView` works with delegates, we must save `completionHandler` and call it later, for example, to handle navigation errors:

```swift
extension WebDataManager: WKNavigationDelegate {
    
    func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
        completionHandler?(.failure(error))
    }
}
```

We starts with refactoring `createData` function in async manner:

```swift
func createData(url: URL, type: DataType) async throws -> Data
```

Before working with web view content, we must be sure that a main frame navigation completes. We can handle it in `webView(_:didFinishüôÇ` function of `WKNavigationDelegate`. To make this logic async\await-compatible, we will use `withCheckedThrowingContinuation` function.

## Interface between synchronous and asynchronous code

Let's white a function to load web content by URL asynchronously:

```swift
private var continuation: CheckedContinuation<Void, Error>?

private func load(_ url: URL) async throws {
    return try await withCheckedThrowingContinuation { continuation in
        self.continuation = continuation
        self.webView.load(.init(url: url))
    }
}
```

We store `continuation` to use it in delegate functions. If you try to run this code, you get an error:

> Call to main actor-isolated instance method 'load' in a synchronous nonisolated context

To fix it we adds a MainActor attribute:

```swift
@MainActor
private func load(_ url: URL) async throws
```

MainActor it a global actor that allow us execute code on the main thread. To handle navigation updates, we adds `continuation` using:

```swift
extension WebDataManager: WKNavigationDelegate {
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        continuation?.resume(returning: ())
    }
    
    func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
        continuation?.resume(throwing: error)
    }
}
```

Now we can call `load` function:

```swift
@MainActor
func createData(url: URL, type: DataType) async throws -> Data {
    try await load(url)
...
```

## Working with system async/await APIs

Now we're ready to rewrite creating web content data. Here's an old example of PDF generation:

```swift
let config = WKPDFConfiguration()
config.rect = .init(origin: .zero, size: webView.scrollView.contentSize)
webView.createPDF(configuration: config) { [weak self] result in
    self?.completionHandler?(result)
}
```

Luckily, Apple team have added async/await analogues for plenty of existing functions with callbacks: 

```swift
let config = WKPDFConfiguration()
config.rect = .init(origin: .zero, size: webView.scrollView.contentSize)
return try await webView.pdf(configuration: config)
```

It works for taking image snapshots as well, but web archive creation is still available only with completion handlers. Here's a good chance for another `withCheckedThrowingContinuation` function:

```swift
import WebKit

extension WKWebView {

    func webArchiveData() async throws -> Data {
        try await withCheckedThrowingContinuation { continuation in
            createWebArchiveData { result in
                continuation.resume(with: result)
            }
        }
    }
}
```

Pay attention continuation can automatically handle the state of the given `Result` value and its associated values.

## Using new async functions

Congratulations, we did it! Wait, but how to use new async functions from sync context? With instances of  `Task` type we can perform async tasks:

```swift
Task {
    do {
        let url - URL(string: "https://www.artemnovichkov.com")!
        let data = try await webDataManager.createData(url: url, type: .pdf)
        print(data)
    }
    catch {
        print(error)
    }
}
```

To get the final result, check [OfflineDataAsyncExample](https://github.com/artemnovichkov/OfflineDataAsyncExample) project on Github.

## Conclusion

–û–±—â–∏–µ –º—ã—Å–ª–∏:

- –õ—É—á—à–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
- –ü—Ä–æ—â–µ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –æ—à–∏–±–∫–∞–º–∏
- –ú–µ–Ω—å—à–µ –∑–∞—Ö–≤–∞—Ç–∞ self –≤ –±–ª–æ–∫–∞—Ö

I'm still playing with new concurrency model and collecting useful resources in [awesome-swift-async-await](https://github.com/artemnovichkov/awesome-swift-async-await) repo. Feel free to send a PR with your favourite learning materials related to this topic!
