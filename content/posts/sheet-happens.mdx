---
title: Sheet happens. Working with modal views in SwiftUI
description: My experience with sheets in SwiftUI based on developing pet projects
cover: /images/sheet-happens/cover.png
date: '2021-04-14'
categories: swiftui
author:
  - artem-novichkov
---

Developing pet projects is one of the best ways to learn new things. Since SwiftUI 1.0 I've been writing an app for saving and reading articles. I rewrote it twice from scratch, added and removed features based on my user experience, used new APIs, etc.

I had a few interesting cases implementing modal views a.k.a. sheets in SwiftUI. The main goal of this article is to summarize my experience and use it as a reference for the future. I simplify code examples to focus on specific logic. Let's start with showing.

<Callout type="info" emoji="️ℹ️">
  Examples are written in Swift 5.3.2 and work on iOS 14.0 with Xcode 12.4 (12D4e).
</Callout>

## Showing sheets

There are two options for showing sheets. 

The first one is based on `Binding<Bool>` value. It can be stored via `@State` property wrapper and good for sheets that need no external data:

```swift
struct ArticlesView: View {

    @State var isSettingsViewPresented = false
    
    var body: some View {
        Button("Show Settings") {
            isSettingsViewPresented = true
        }
        .sheet(isPresented: $isSettingsViewPresented) {
            SettingsView()
        }
    }
}

struct SettingsView: View {

    var body: some View {
        Text("Settings")
    }
}
```

The second one is based on `Binding<Item?>` value where the item is an optional Identifiable object. it's a good choice if we want to pass any data to sheets. For instance, a selected article for reading. Pay attention that the selected article is not optional in sheet content closure:

```swift
// A simple struct with article data

struct Article: Identifiable {

    let id: UUID
    let title: String
}

struct ArticlesView: View {

    @State var article: Article?
    
    var body: some View {
        Button("Show Article") {
            article = .init(id: .init(), title: "Awesome article")
        }
        .sheet(item: $article) { article in
            ArticleDetailsView(article: article)
        }
    }
}

// A view for article showing

struct ArticleDetailsView: View {

    @State var article: Article
    
    var body: some View {
        Text(article.title)
    }
}
```

Interesting moments here:

- if `id` of the selected article will be changed, the presented sheet will be dismissed and replaced with a new sheet;
- if the selected article becomes nil at any moment, the sheet will be dismissed as well. 

For both showing options we can optionally add `onDismiss` closure that executed when the sheet dismisses:

```swift
struct ArticlesView: View {

    @State var article: Article?
    
    var body: some View {
        Button("Show Article") {
            article = .init(id: .init(), title: "Awesome article")
        }
        .sheet(item: $article, onDismiss: onDismiss) { article in
            ArticleDetailsView(article: article)
        }
    }
       
    private func onDismiss() {
        print("dismisses")
    }
}
```

By default, we can dismiss sheets via swipe gestures. But what if we want to dismiss sheets based on another user action or app logic?

## Dismissing sheets

There are two options to dismiss sheets too. If we use `Binding<Bool>`, we can pass it to a sheet via `@Binding` property wrapper and update its value. Bindings allow to change values in parent views:

```swift
// in ArticlesView

.sheet(isPresented: $isSettingsViewPresented) {
    SettingsView(isSettingsViewPresented: $isSettingsViewPresented)
}

struct SettingsView: View {
    
    @Binding var isSettingsViewPresented: Bool
    
    var body: some View {
        ZStack {
            Text("Settings")
            VStack {
                Spacer()
                Button("Dismiss") {
                    isSettingsViewPresented = false
                }
            }
        }
    }
}
```